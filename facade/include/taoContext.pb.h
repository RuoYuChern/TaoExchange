// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: taoContext.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_taoContext_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_taoContext_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4022000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4022002 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_taoContext_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_taoContext_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_taoContext_2eproto;
namespace taocontext {
class MarketDto;
struct MarketDtoDefaultTypeInternal;
extern MarketDtoDefaultTypeInternal _MarketDto_default_instance_;
class OrderDto;
struct OrderDtoDefaultTypeInternal;
extern OrderDtoDefaultTypeInternal _OrderDto_default_instance_;
class OrderReplyDto;
struct OrderReplyDtoDefaultTypeInternal;
extern OrderReplyDtoDefaultTypeInternal _OrderReplyDto_default_instance_;
}  // namespace taocontext
PROTOBUF_NAMESPACE_OPEN
template <>
::taocontext::MarketDto* Arena::CreateMaybeMessage<::taocontext::MarketDto>(Arena*);
template <>
::taocontext::OrderDto* Arena::CreateMaybeMessage<::taocontext::OrderDto>(Arena*);
template <>
::taocontext::OrderReplyDto* Arena::CreateMaybeMessage<::taocontext::OrderReplyDto>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace taocontext {
enum OrderType : int {
  GTC = 0,
  IOC = 1,
  IOC_BUDGET = 2,
  FOK = 3,
  FOK_BUDGET = 4,
  OrderType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OrderType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OrderType_IsValid(int value);
constexpr OrderType OrderType_MIN = static_cast<OrderType>(0);
constexpr OrderType OrderType_MAX = static_cast<OrderType>(4);
constexpr int OrderType_ARRAYSIZE = 4 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
OrderType_descriptor();
template <typename T>
const std::string& OrderType_Name(T value) {
  static_assert(std::is_same<T, OrderType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OrderType_Name().");
  return OrderType_Name(static_cast<OrderType>(value));
}
template <>
inline const std::string& OrderType_Name(OrderType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<OrderType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool OrderType_Parse(absl::string_view name, OrderType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderType>(
      OrderType_descriptor(), name, value);
}
enum OrderSid : int {
  OFFER = 0,
  BID = 1,
  OrderSid_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OrderSid_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OrderSid_IsValid(int value);
constexpr OrderSid OrderSid_MIN = static_cast<OrderSid>(0);
constexpr OrderSid OrderSid_MAX = static_cast<OrderSid>(1);
constexpr int OrderSid_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
OrderSid_descriptor();
template <typename T>
const std::string& OrderSid_Name(T value) {
  static_assert(std::is_same<T, OrderSid>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OrderSid_Name().");
  return OrderSid_Name(static_cast<OrderSid>(value));
}
template <>
inline const std::string& OrderSid_Name(OrderSid value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<OrderSid_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool OrderSid_Parse(absl::string_view name, OrderSid* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderSid>(
      OrderSid_descriptor(), name, value);
}
enum OrderCmd : int {
  PLACE = 0,
  MOVE = 1,
  CANCEL = 2,
  REDUCE = 3,
  REJECT = 4,
  ACCEPT = 5,
  OrderCmd_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OrderCmd_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OrderCmd_IsValid(int value);
constexpr OrderCmd OrderCmd_MIN = static_cast<OrderCmd>(0);
constexpr OrderCmd OrderCmd_MAX = static_cast<OrderCmd>(5);
constexpr int OrderCmd_ARRAYSIZE = 5 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
OrderCmd_descriptor();
template <typename T>
const std::string& OrderCmd_Name(T value) {
  static_assert(std::is_same<T, OrderCmd>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OrderCmd_Name().");
  return OrderCmd_Name(static_cast<OrderCmd>(value));
}
template <>
inline const std::string& OrderCmd_Name(OrderCmd value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<OrderCmd_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool OrderCmd_Parse(absl::string_view name, OrderCmd* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderCmd>(
      OrderCmd_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class OrderDto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:taocontext.OrderDto) */ {
 public:
  inline OrderDto() : OrderDto(nullptr) {}
  ~OrderDto() override;
  explicit PROTOBUF_CONSTEXPR OrderDto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderDto(const OrderDto& from);
  OrderDto(OrderDto&& from) noexcept
    : OrderDto() {
    *this = ::std::move(from);
  }

  inline OrderDto& operator=(const OrderDto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderDto& operator=(OrderDto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderDto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderDto* internal_default_instance() {
    return reinterpret_cast<const OrderDto*>(
               &_OrderDto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(OrderDto& a, OrderDto& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderDto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderDto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderDto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderDto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderDto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderDto& from) {
    OrderDto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderDto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "taocontext.OrderDto";
  }
  protected:
  explicit OrderDto(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kMarketFieldNumber = 13,
    kUserIdFieldNumber = 14,
    kSourceFieldNumber = 15,
    kTypeFieldNumber = 2,
    kSideFieldNumber = 3,
    kCommondFieldNumber = 4,
    kVersionFieldNumber = 5,
    kTimestampFieldNumber = 6,
    kPriceFieldNumber = 7,
    kReserveBidPriceFieldNumber = 8,
    kAmountFieldNumber = 9,
    kTakerFeeFieldNumber = 11,
    kMakerFeeFieldNumber = 12,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string market = 13;
  void clear_market() ;
  const std::string& market() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market(Arg_&& arg, Args_... args);
  std::string* mutable_market();
  PROTOBUF_NODISCARD std::string* release_market();
  void set_allocated_market(std::string* ptr);

  private:
  const std::string& _internal_market() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market(
      const std::string& value);
  std::string* _internal_mutable_market();

  public:
  // string userId = 14;
  void clear_userid() ;
  const std::string& userid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_userid(Arg_&& arg, Args_... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* ptr);

  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(
      const std::string& value);
  std::string* _internal_mutable_userid();

  public:
  // string source = 15;
  void clear_source() ;
  const std::string& source() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source(Arg_&& arg, Args_... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* ptr);

  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(
      const std::string& value);
  std::string* _internal_mutable_source();

  public:
  // .taocontext.OrderType type = 2;
  void clear_type() ;
  ::taocontext::OrderType type() const;
  void set_type(::taocontext::OrderType value);

  private:
  ::taocontext::OrderType _internal_type() const;
  void _internal_set_type(::taocontext::OrderType value);

  public:
  // .taocontext.OrderSid side = 3;
  void clear_side() ;
  ::taocontext::OrderSid side() const;
  void set_side(::taocontext::OrderSid value);

  private:
  ::taocontext::OrderSid _internal_side() const;
  void _internal_set_side(::taocontext::OrderSid value);

  public:
  // .taocontext.OrderCmd commond = 4;
  void clear_commond() ;
  ::taocontext::OrderCmd commond() const;
  void set_commond(::taocontext::OrderCmd value);

  private:
  ::taocontext::OrderCmd _internal_commond() const;
  void _internal_set_commond(::taocontext::OrderCmd value);

  public:
  // int32 version = 5;
  void clear_version() ;
  ::int32_t version() const;
  void set_version(::int32_t value);

  private:
  ::int32_t _internal_version() const;
  void _internal_set_version(::int32_t value);

  public:
  // int64 timestamp = 6;
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // int64 price = 7;
  void clear_price() ;
  ::int64_t price() const;
  void set_price(::int64_t value);

  private:
  ::int64_t _internal_price() const;
  void _internal_set_price(::int64_t value);

  public:
  // int64 reserveBidPrice = 8;
  void clear_reservebidprice() ;
  ::int64_t reservebidprice() const;
  void set_reservebidprice(::int64_t value);

  private:
  ::int64_t _internal_reservebidprice() const;
  void _internal_set_reservebidprice(::int64_t value);

  public:
  // int64 amount = 9;
  void clear_amount() ;
  ::int64_t amount() const;
  void set_amount(::int64_t value);

  private:
  ::int64_t _internal_amount() const;
  void _internal_set_amount(::int64_t value);

  public:
  // int64 takerFee = 11;
  void clear_takerfee() ;
  ::int64_t takerfee() const;
  void set_takerfee(::int64_t value);

  private:
  ::int64_t _internal_takerfee() const;
  void _internal_set_takerfee(::int64_t value);

  public:
  // int64 makerFee = 12;
  void clear_makerfee() ;
  ::int64_t makerfee() const;
  void set_makerfee(::int64_t value);

  private:
  ::int64_t _internal_makerfee() const;
  void _internal_set_makerfee(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:taocontext.OrderDto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
    int type_;
    int side_;
    int commond_;
    ::int32_t version_;
    ::int64_t timestamp_;
    ::int64_t price_;
    ::int64_t reservebidprice_;
    ::int64_t amount_;
    ::int64_t takerfee_;
    ::int64_t makerfee_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_taoContext_2eproto;
};// -------------------------------------------------------------------

class OrderReplyDto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:taocontext.OrderReplyDto) */ {
 public:
  inline OrderReplyDto() : OrderReplyDto(nullptr) {}
  ~OrderReplyDto() override;
  explicit PROTOBUF_CONSTEXPR OrderReplyDto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderReplyDto(const OrderReplyDto& from);
  OrderReplyDto(OrderReplyDto&& from) noexcept
    : OrderReplyDto() {
    *this = ::std::move(from);
  }

  inline OrderReplyDto& operator=(const OrderReplyDto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderReplyDto& operator=(OrderReplyDto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderReplyDto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderReplyDto* internal_default_instance() {
    return reinterpret_cast<const OrderReplyDto*>(
               &_OrderReplyDto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OrderReplyDto& a, OrderReplyDto& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderReplyDto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderReplyDto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderReplyDto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderReplyDto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderReplyDto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderReplyDto& from) {
    OrderReplyDto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderReplyDto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "taocontext.OrderReplyDto";
  }
  protected:
  explicit OrderReplyDto(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplyIdFieldNumber = 1,
    kOrderFieldNumber = 2,
    kFilledFieldNumber = 4,
    kLeftFieldNumber = 5,
    kFreeFieldNumber = 6,
    kCommondFieldNumber = 3,
  };
  // string replyId = 1;
  void clear_replyid() ;
  const std::string& replyid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_replyid(Arg_&& arg, Args_... args);
  std::string* mutable_replyid();
  PROTOBUF_NODISCARD std::string* release_replyid();
  void set_allocated_replyid(std::string* ptr);

  private:
  const std::string& _internal_replyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_replyid(
      const std::string& value);
  std::string* _internal_mutable_replyid();

  public:
  // .taocontext.OrderDto order = 2;
  bool has_order() const;
  private:
  bool _internal_has_order() const;

  public:
  void clear_order() ;
  const ::taocontext::OrderDto& order() const;
  PROTOBUF_NODISCARD ::taocontext::OrderDto* release_order();
  ::taocontext::OrderDto* mutable_order();
  void set_allocated_order(::taocontext::OrderDto* order);
  private:
  const ::taocontext::OrderDto& _internal_order() const;
  ::taocontext::OrderDto* _internal_mutable_order();
  public:
  void unsafe_arena_set_allocated_order(
      ::taocontext::OrderDto* order);
  ::taocontext::OrderDto* unsafe_arena_release_order();
  // int64 filled = 4;
  void clear_filled() ;
  ::int64_t filled() const;
  void set_filled(::int64_t value);

  private:
  ::int64_t _internal_filled() const;
  void _internal_set_filled(::int64_t value);

  public:
  // int64 left = 5;
  void clear_left() ;
  ::int64_t left() const;
  void set_left(::int64_t value);

  private:
  ::int64_t _internal_left() const;
  void _internal_set_left(::int64_t value);

  public:
  // int64 free = 6;
  void clear_free() ;
  ::int64_t free() const;
  void set_free(::int64_t value);

  private:
  ::int64_t _internal_free() const;
  void _internal_set_free(::int64_t value);

  public:
  // .taocontext.OrderCmd commond = 3;
  void clear_commond() ;
  ::taocontext::OrderCmd commond() const;
  void set_commond(::taocontext::OrderCmd value);

  private:
  ::taocontext::OrderCmd _internal_commond() const;
  void _internal_set_commond(::taocontext::OrderCmd value);

  public:
  // @@protoc_insertion_point(class_scope:taocontext.OrderReplyDto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr replyid_;
    ::taocontext::OrderDto* order_;
    ::int64_t filled_;
    ::int64_t left_;
    ::int64_t free_;
    int commond_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_taoContext_2eproto;
};// -------------------------------------------------------------------

class MarketDto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:taocontext.MarketDto) */ {
 public:
  inline MarketDto() : MarketDto(nullptr) {}
  ~MarketDto() override;
  explicit PROTOBUF_CONSTEXPR MarketDto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketDto(const MarketDto& from);
  MarketDto(MarketDto&& from) noexcept
    : MarketDto() {
    *this = ::std::move(from);
  }

  inline MarketDto& operator=(const MarketDto& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketDto& operator=(MarketDto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketDto& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketDto* internal_default_instance() {
    return reinterpret_cast<const MarketDto*>(
               &_MarketDto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MarketDto& a, MarketDto& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketDto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketDto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketDto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketDto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketDto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarketDto& from) {
    MarketDto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketDto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "taocontext.MarketDto";
  }
  protected:
  explicit MarketDto(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSymbolFieldNumber = 1,
    kTargetFieldNumber = 2,
    kMoneyFieldNumber = 3,
    kTargetPrecFieldNumber = 4,
    kMoneyPrecFieldNumber = 5,
    kMinAmountFieldNumber = 7,
    kMinBaseFieldNumber = 8,
    kFeePrecFieldNumber = 6,
  };
  // string symbol = 1;
  void clear_symbol() ;
  const std::string& symbol() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* ptr);

  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(
      const std::string& value);
  std::string* _internal_mutable_symbol();

  public:
  // string target = 2;
  void clear_target() ;
  const std::string& target() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target(Arg_&& arg, Args_... args);
  std::string* mutable_target();
  PROTOBUF_NODISCARD std::string* release_target();
  void set_allocated_target(std::string* ptr);

  private:
  const std::string& _internal_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target(
      const std::string& value);
  std::string* _internal_mutable_target();

  public:
  // string money = 3;
  void clear_money() ;
  const std::string& money() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_money(Arg_&& arg, Args_... args);
  std::string* mutable_money();
  PROTOBUF_NODISCARD std::string* release_money();
  void set_allocated_money(std::string* ptr);

  private:
  const std::string& _internal_money() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_money(
      const std::string& value);
  std::string* _internal_mutable_money();

  public:
  // int32 targetPrec = 4;
  void clear_targetprec() ;
  ::int32_t targetprec() const;
  void set_targetprec(::int32_t value);

  private:
  ::int32_t _internal_targetprec() const;
  void _internal_set_targetprec(::int32_t value);

  public:
  // int32 moneyPrec = 5;
  void clear_moneyprec() ;
  ::int32_t moneyprec() const;
  void set_moneyprec(::int32_t value);

  private:
  ::int32_t _internal_moneyprec() const;
  void _internal_set_moneyprec(::int32_t value);

  public:
  // int64 minAmount = 7;
  void clear_minamount() ;
  ::int64_t minamount() const;
  void set_minamount(::int64_t value);

  private:
  ::int64_t _internal_minamount() const;
  void _internal_set_minamount(::int64_t value);

  public:
  // int64 minBase = 8;
  void clear_minbase() ;
  ::int64_t minbase() const;
  void set_minbase(::int64_t value);

  private:
  ::int64_t _internal_minbase() const;
  void _internal_set_minbase(::int64_t value);

  public:
  // int32 feePrec = 6;
  void clear_feeprec() ;
  ::int32_t feeprec() const;
  void set_feeprec(::int32_t value);

  private:
  ::int32_t _internal_feeprec() const;
  void _internal_set_feeprec(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:taocontext.MarketDto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr money_;
    ::int32_t targetprec_;
    ::int32_t moneyprec_;
    ::int64_t minamount_;
    ::int64_t minbase_;
    ::int32_t feeprec_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_taoContext_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// OrderDto

// string id = 1;
inline void OrderDto::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& OrderDto::id() const {
  // @@protoc_insertion_point(field_get:taocontext.OrderDto.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderDto::set_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taocontext.OrderDto.id)
}
inline std::string* OrderDto::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:taocontext.OrderDto.id)
  return _s;
}
inline const std::string& OrderDto::_internal_id() const {
  return _impl_.id_.Get();
}
inline void OrderDto::_internal_set_id(const std::string& value) {
  ;


  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderDto::_internal_mutable_id() {
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderDto::release_id() {
  // @@protoc_insertion_point(field_release:taocontext.OrderDto.id)
  return _impl_.id_.Release();
}
inline void OrderDto::set_allocated_id(std::string* value) {
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:taocontext.OrderDto.id)
}

// .taocontext.OrderType type = 2;
inline void OrderDto::clear_type() {
  _impl_.type_ = 0;
}
inline ::taocontext::OrderType OrderDto::type() const {
  // @@protoc_insertion_point(field_get:taocontext.OrderDto.type)
  return _internal_type();
}
inline void OrderDto::set_type(::taocontext::OrderType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:taocontext.OrderDto.type)
}
inline ::taocontext::OrderType OrderDto::_internal_type() const {
  return static_cast<::taocontext::OrderType>(_impl_.type_);
}
inline void OrderDto::_internal_set_type(::taocontext::OrderType value) {
  ;
  _impl_.type_ = value;
}

// .taocontext.OrderSid side = 3;
inline void OrderDto::clear_side() {
  _impl_.side_ = 0;
}
inline ::taocontext::OrderSid OrderDto::side() const {
  // @@protoc_insertion_point(field_get:taocontext.OrderDto.side)
  return _internal_side();
}
inline void OrderDto::set_side(::taocontext::OrderSid value) {
   _internal_set_side(value);
  // @@protoc_insertion_point(field_set:taocontext.OrderDto.side)
}
inline ::taocontext::OrderSid OrderDto::_internal_side() const {
  return static_cast<::taocontext::OrderSid>(_impl_.side_);
}
inline void OrderDto::_internal_set_side(::taocontext::OrderSid value) {
  ;
  _impl_.side_ = value;
}

// .taocontext.OrderCmd commond = 4;
inline void OrderDto::clear_commond() {
  _impl_.commond_ = 0;
}
inline ::taocontext::OrderCmd OrderDto::commond() const {
  // @@protoc_insertion_point(field_get:taocontext.OrderDto.commond)
  return _internal_commond();
}
inline void OrderDto::set_commond(::taocontext::OrderCmd value) {
   _internal_set_commond(value);
  // @@protoc_insertion_point(field_set:taocontext.OrderDto.commond)
}
inline ::taocontext::OrderCmd OrderDto::_internal_commond() const {
  return static_cast<::taocontext::OrderCmd>(_impl_.commond_);
}
inline void OrderDto::_internal_set_commond(::taocontext::OrderCmd value) {
  ;
  _impl_.commond_ = value;
}

// int32 version = 5;
inline void OrderDto::clear_version() {
  _impl_.version_ = 0;
}
inline ::int32_t OrderDto::version() const {
  // @@protoc_insertion_point(field_get:taocontext.OrderDto.version)
  return _internal_version();
}
inline void OrderDto::set_version(::int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:taocontext.OrderDto.version)
}
inline ::int32_t OrderDto::_internal_version() const {
  return _impl_.version_;
}
inline void OrderDto::_internal_set_version(::int32_t value) {
  ;
  _impl_.version_ = value;
}

// int64 timestamp = 6;
inline void OrderDto::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t OrderDto::timestamp() const {
  // @@protoc_insertion_point(field_get:taocontext.OrderDto.timestamp)
  return _internal_timestamp();
}
inline void OrderDto::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:taocontext.OrderDto.timestamp)
}
inline ::int64_t OrderDto::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void OrderDto::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// int64 price = 7;
inline void OrderDto::clear_price() {
  _impl_.price_ = ::int64_t{0};
}
inline ::int64_t OrderDto::price() const {
  // @@protoc_insertion_point(field_get:taocontext.OrderDto.price)
  return _internal_price();
}
inline void OrderDto::set_price(::int64_t value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:taocontext.OrderDto.price)
}
inline ::int64_t OrderDto::_internal_price() const {
  return _impl_.price_;
}
inline void OrderDto::_internal_set_price(::int64_t value) {
  ;
  _impl_.price_ = value;
}

// int64 reserveBidPrice = 8;
inline void OrderDto::clear_reservebidprice() {
  _impl_.reservebidprice_ = ::int64_t{0};
}
inline ::int64_t OrderDto::reservebidprice() const {
  // @@protoc_insertion_point(field_get:taocontext.OrderDto.reserveBidPrice)
  return _internal_reservebidprice();
}
inline void OrderDto::set_reservebidprice(::int64_t value) {
  _internal_set_reservebidprice(value);
  // @@protoc_insertion_point(field_set:taocontext.OrderDto.reserveBidPrice)
}
inline ::int64_t OrderDto::_internal_reservebidprice() const {
  return _impl_.reservebidprice_;
}
inline void OrderDto::_internal_set_reservebidprice(::int64_t value) {
  ;
  _impl_.reservebidprice_ = value;
}

// int64 amount = 9;
inline void OrderDto::clear_amount() {
  _impl_.amount_ = ::int64_t{0};
}
inline ::int64_t OrderDto::amount() const {
  // @@protoc_insertion_point(field_get:taocontext.OrderDto.amount)
  return _internal_amount();
}
inline void OrderDto::set_amount(::int64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:taocontext.OrderDto.amount)
}
inline ::int64_t OrderDto::_internal_amount() const {
  return _impl_.amount_;
}
inline void OrderDto::_internal_set_amount(::int64_t value) {
  ;
  _impl_.amount_ = value;
}

// int64 takerFee = 11;
inline void OrderDto::clear_takerfee() {
  _impl_.takerfee_ = ::int64_t{0};
}
inline ::int64_t OrderDto::takerfee() const {
  // @@protoc_insertion_point(field_get:taocontext.OrderDto.takerFee)
  return _internal_takerfee();
}
inline void OrderDto::set_takerfee(::int64_t value) {
  _internal_set_takerfee(value);
  // @@protoc_insertion_point(field_set:taocontext.OrderDto.takerFee)
}
inline ::int64_t OrderDto::_internal_takerfee() const {
  return _impl_.takerfee_;
}
inline void OrderDto::_internal_set_takerfee(::int64_t value) {
  ;
  _impl_.takerfee_ = value;
}

// int64 makerFee = 12;
inline void OrderDto::clear_makerfee() {
  _impl_.makerfee_ = ::int64_t{0};
}
inline ::int64_t OrderDto::makerfee() const {
  // @@protoc_insertion_point(field_get:taocontext.OrderDto.makerFee)
  return _internal_makerfee();
}
inline void OrderDto::set_makerfee(::int64_t value) {
  _internal_set_makerfee(value);
  // @@protoc_insertion_point(field_set:taocontext.OrderDto.makerFee)
}
inline ::int64_t OrderDto::_internal_makerfee() const {
  return _impl_.makerfee_;
}
inline void OrderDto::_internal_set_makerfee(::int64_t value) {
  ;
  _impl_.makerfee_ = value;
}

// string market = 13;
inline void OrderDto::clear_market() {
  _impl_.market_.ClearToEmpty();
}
inline const std::string& OrderDto::market() const {
  // @@protoc_insertion_point(field_get:taocontext.OrderDto.market)
  return _internal_market();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderDto::set_market(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taocontext.OrderDto.market)
}
inline std::string* OrderDto::mutable_market() {
  std::string* _s = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:taocontext.OrderDto.market)
  return _s;
}
inline const std::string& OrderDto::_internal_market() const {
  return _impl_.market_.Get();
}
inline void OrderDto::_internal_set_market(const std::string& value) {
  ;


  _impl_.market_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderDto::_internal_mutable_market() {
  ;
  return _impl_.market_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderDto::release_market() {
  // @@protoc_insertion_point(field_release:taocontext.OrderDto.market)
  return _impl_.market_.Release();
}
inline void OrderDto::set_allocated_market(std::string* value) {
  _impl_.market_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_.IsDefault()) {
          _impl_.market_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:taocontext.OrderDto.market)
}

// string userId = 14;
inline void OrderDto::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& OrderDto::userid() const {
  // @@protoc_insertion_point(field_get:taocontext.OrderDto.userId)
  return _internal_userid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderDto::set_userid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.userid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taocontext.OrderDto.userId)
}
inline std::string* OrderDto::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:taocontext.OrderDto.userId)
  return _s;
}
inline const std::string& OrderDto::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void OrderDto::_internal_set_userid(const std::string& value) {
  ;


  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderDto::_internal_mutable_userid() {
  ;
  return _impl_.userid_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderDto::release_userid() {
  // @@protoc_insertion_point(field_release:taocontext.OrderDto.userId)
  return _impl_.userid_.Release();
}
inline void OrderDto::set_allocated_userid(std::string* value) {
  _impl_.userid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.userid_.IsDefault()) {
          _impl_.userid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:taocontext.OrderDto.userId)
}

// string source = 15;
inline void OrderDto::clear_source() {
  _impl_.source_.ClearToEmpty();
}
inline const std::string& OrderDto::source() const {
  // @@protoc_insertion_point(field_get:taocontext.OrderDto.source)
  return _internal_source();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderDto::set_source(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.source_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taocontext.OrderDto.source)
}
inline std::string* OrderDto::mutable_source() {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:taocontext.OrderDto.source)
  return _s;
}
inline const std::string& OrderDto::_internal_source() const {
  return _impl_.source_.Get();
}
inline void OrderDto::_internal_set_source(const std::string& value) {
  ;


  _impl_.source_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderDto::_internal_mutable_source() {
  ;
  return _impl_.source_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderDto::release_source() {
  // @@protoc_insertion_point(field_release:taocontext.OrderDto.source)
  return _impl_.source_.Release();
}
inline void OrderDto::set_allocated_source(std::string* value) {
  _impl_.source_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_.IsDefault()) {
          _impl_.source_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:taocontext.OrderDto.source)
}

// -------------------------------------------------------------------

// OrderReplyDto

// string replyId = 1;
inline void OrderReplyDto::clear_replyid() {
  _impl_.replyid_.ClearToEmpty();
}
inline const std::string& OrderReplyDto::replyid() const {
  // @@protoc_insertion_point(field_get:taocontext.OrderReplyDto.replyId)
  return _internal_replyid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderReplyDto::set_replyid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.replyid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taocontext.OrderReplyDto.replyId)
}
inline std::string* OrderReplyDto::mutable_replyid() {
  std::string* _s = _internal_mutable_replyid();
  // @@protoc_insertion_point(field_mutable:taocontext.OrderReplyDto.replyId)
  return _s;
}
inline const std::string& OrderReplyDto::_internal_replyid() const {
  return _impl_.replyid_.Get();
}
inline void OrderReplyDto::_internal_set_replyid(const std::string& value) {
  ;


  _impl_.replyid_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderReplyDto::_internal_mutable_replyid() {
  ;
  return _impl_.replyid_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderReplyDto::release_replyid() {
  // @@protoc_insertion_point(field_release:taocontext.OrderReplyDto.replyId)
  return _impl_.replyid_.Release();
}
inline void OrderReplyDto::set_allocated_replyid(std::string* value) {
  _impl_.replyid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.replyid_.IsDefault()) {
          _impl_.replyid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:taocontext.OrderReplyDto.replyId)
}

// .taocontext.OrderDto order = 2;
inline bool OrderReplyDto::_internal_has_order() const {
  return this != internal_default_instance() && _impl_.order_ != nullptr;
}
inline bool OrderReplyDto::has_order() const {
  return _internal_has_order();
}
inline void OrderReplyDto::clear_order() {
  if (GetArenaForAllocation() == nullptr && _impl_.order_ != nullptr) {
    delete _impl_.order_;
  }
  _impl_.order_ = nullptr;
}
inline const ::taocontext::OrderDto& OrderReplyDto::_internal_order() const {
  const ::taocontext::OrderDto* p = _impl_.order_;
  return p != nullptr ? *p : reinterpret_cast<const ::taocontext::OrderDto&>(
      ::taocontext::_OrderDto_default_instance_);
}
inline const ::taocontext::OrderDto& OrderReplyDto::order() const {
  // @@protoc_insertion_point(field_get:taocontext.OrderReplyDto.order)
  return _internal_order();
}
inline void OrderReplyDto::unsafe_arena_set_allocated_order(
    ::taocontext::OrderDto* order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  _impl_.order_ = order;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:taocontext.OrderReplyDto.order)
}
inline ::taocontext::OrderDto* OrderReplyDto::release_order() {
  
  ::taocontext::OrderDto* temp = _impl_.order_;
  _impl_.order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::taocontext::OrderDto* OrderReplyDto::unsafe_arena_release_order() {
  // @@protoc_insertion_point(field_release:taocontext.OrderReplyDto.order)
  
  ::taocontext::OrderDto* temp = _impl_.order_;
  _impl_.order_ = nullptr;
  return temp;
}
inline ::taocontext::OrderDto* OrderReplyDto::_internal_mutable_order() {
  
  if (_impl_.order_ == nullptr) {
    auto* p = CreateMaybeMessage<::taocontext::OrderDto>(GetArenaForAllocation());
    _impl_.order_ = p;
  }
  return _impl_.order_;
}
inline ::taocontext::OrderDto* OrderReplyDto::mutable_order() {
  ::taocontext::OrderDto* _msg = _internal_mutable_order();
  // @@protoc_insertion_point(field_mutable:taocontext.OrderReplyDto.order)
  return _msg;
}
inline void OrderReplyDto::set_allocated_order(::taocontext::OrderDto* order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.order_;
  }
  if (order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(order);
    if (message_arena != submessage_arena) {
      order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }

  } else {

  }
  _impl_.order_ = order;
  // @@protoc_insertion_point(field_set_allocated:taocontext.OrderReplyDto.order)
}

// .taocontext.OrderCmd commond = 3;
inline void OrderReplyDto::clear_commond() {
  _impl_.commond_ = 0;
}
inline ::taocontext::OrderCmd OrderReplyDto::commond() const {
  // @@protoc_insertion_point(field_get:taocontext.OrderReplyDto.commond)
  return _internal_commond();
}
inline void OrderReplyDto::set_commond(::taocontext::OrderCmd value) {
   _internal_set_commond(value);
  // @@protoc_insertion_point(field_set:taocontext.OrderReplyDto.commond)
}
inline ::taocontext::OrderCmd OrderReplyDto::_internal_commond() const {
  return static_cast<::taocontext::OrderCmd>(_impl_.commond_);
}
inline void OrderReplyDto::_internal_set_commond(::taocontext::OrderCmd value) {
  ;
  _impl_.commond_ = value;
}

// int64 filled = 4;
inline void OrderReplyDto::clear_filled() {
  _impl_.filled_ = ::int64_t{0};
}
inline ::int64_t OrderReplyDto::filled() const {
  // @@protoc_insertion_point(field_get:taocontext.OrderReplyDto.filled)
  return _internal_filled();
}
inline void OrderReplyDto::set_filled(::int64_t value) {
  _internal_set_filled(value);
  // @@protoc_insertion_point(field_set:taocontext.OrderReplyDto.filled)
}
inline ::int64_t OrderReplyDto::_internal_filled() const {
  return _impl_.filled_;
}
inline void OrderReplyDto::_internal_set_filled(::int64_t value) {
  ;
  _impl_.filled_ = value;
}

// int64 left = 5;
inline void OrderReplyDto::clear_left() {
  _impl_.left_ = ::int64_t{0};
}
inline ::int64_t OrderReplyDto::left() const {
  // @@protoc_insertion_point(field_get:taocontext.OrderReplyDto.left)
  return _internal_left();
}
inline void OrderReplyDto::set_left(::int64_t value) {
  _internal_set_left(value);
  // @@protoc_insertion_point(field_set:taocontext.OrderReplyDto.left)
}
inline ::int64_t OrderReplyDto::_internal_left() const {
  return _impl_.left_;
}
inline void OrderReplyDto::_internal_set_left(::int64_t value) {
  ;
  _impl_.left_ = value;
}

// int64 free = 6;
inline void OrderReplyDto::clear_free() {
  _impl_.free_ = ::int64_t{0};
}
inline ::int64_t OrderReplyDto::free() const {
  // @@protoc_insertion_point(field_get:taocontext.OrderReplyDto.free)
  return _internal_free();
}
inline void OrderReplyDto::set_free(::int64_t value) {
  _internal_set_free(value);
  // @@protoc_insertion_point(field_set:taocontext.OrderReplyDto.free)
}
inline ::int64_t OrderReplyDto::_internal_free() const {
  return _impl_.free_;
}
inline void OrderReplyDto::_internal_set_free(::int64_t value) {
  ;
  _impl_.free_ = value;
}

// -------------------------------------------------------------------

// MarketDto

// string symbol = 1;
inline void MarketDto::clear_symbol() {
  _impl_.symbol_.ClearToEmpty();
}
inline const std::string& MarketDto::symbol() const {
  // @@protoc_insertion_point(field_get:taocontext.MarketDto.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MarketDto::set_symbol(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taocontext.MarketDto.symbol)
}
inline std::string* MarketDto::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:taocontext.MarketDto.symbol)
  return _s;
}
inline const std::string& MarketDto::_internal_symbol() const {
  return _impl_.symbol_.Get();
}
inline void MarketDto::_internal_set_symbol(const std::string& value) {
  ;


  _impl_.symbol_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketDto::_internal_mutable_symbol() {
  ;
  return _impl_.symbol_.Mutable( GetArenaForAllocation());
}
inline std::string* MarketDto::release_symbol() {
  // @@protoc_insertion_point(field_release:taocontext.MarketDto.symbol)
  return _impl_.symbol_.Release();
}
inline void MarketDto::set_allocated_symbol(std::string* value) {
  _impl_.symbol_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.symbol_.IsDefault()) {
          _impl_.symbol_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:taocontext.MarketDto.symbol)
}

// string target = 2;
inline void MarketDto::clear_target() {
  _impl_.target_.ClearToEmpty();
}
inline const std::string& MarketDto::target() const {
  // @@protoc_insertion_point(field_get:taocontext.MarketDto.target)
  return _internal_target();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MarketDto::set_target(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.target_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taocontext.MarketDto.target)
}
inline std::string* MarketDto::mutable_target() {
  std::string* _s = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:taocontext.MarketDto.target)
  return _s;
}
inline const std::string& MarketDto::_internal_target() const {
  return _impl_.target_.Get();
}
inline void MarketDto::_internal_set_target(const std::string& value) {
  ;


  _impl_.target_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketDto::_internal_mutable_target() {
  ;
  return _impl_.target_.Mutable( GetArenaForAllocation());
}
inline std::string* MarketDto::release_target() {
  // @@protoc_insertion_point(field_release:taocontext.MarketDto.target)
  return _impl_.target_.Release();
}
inline void MarketDto::set_allocated_target(std::string* value) {
  _impl_.target_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_.IsDefault()) {
          _impl_.target_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:taocontext.MarketDto.target)
}

// string money = 3;
inline void MarketDto::clear_money() {
  _impl_.money_.ClearToEmpty();
}
inline const std::string& MarketDto::money() const {
  // @@protoc_insertion_point(field_get:taocontext.MarketDto.money)
  return _internal_money();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MarketDto::set_money(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.money_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taocontext.MarketDto.money)
}
inline std::string* MarketDto::mutable_money() {
  std::string* _s = _internal_mutable_money();
  // @@protoc_insertion_point(field_mutable:taocontext.MarketDto.money)
  return _s;
}
inline const std::string& MarketDto::_internal_money() const {
  return _impl_.money_.Get();
}
inline void MarketDto::_internal_set_money(const std::string& value) {
  ;


  _impl_.money_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketDto::_internal_mutable_money() {
  ;
  return _impl_.money_.Mutable( GetArenaForAllocation());
}
inline std::string* MarketDto::release_money() {
  // @@protoc_insertion_point(field_release:taocontext.MarketDto.money)
  return _impl_.money_.Release();
}
inline void MarketDto::set_allocated_money(std::string* value) {
  _impl_.money_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.money_.IsDefault()) {
          _impl_.money_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:taocontext.MarketDto.money)
}

// int32 targetPrec = 4;
inline void MarketDto::clear_targetprec() {
  _impl_.targetprec_ = 0;
}
inline ::int32_t MarketDto::targetprec() const {
  // @@protoc_insertion_point(field_get:taocontext.MarketDto.targetPrec)
  return _internal_targetprec();
}
inline void MarketDto::set_targetprec(::int32_t value) {
  _internal_set_targetprec(value);
  // @@protoc_insertion_point(field_set:taocontext.MarketDto.targetPrec)
}
inline ::int32_t MarketDto::_internal_targetprec() const {
  return _impl_.targetprec_;
}
inline void MarketDto::_internal_set_targetprec(::int32_t value) {
  ;
  _impl_.targetprec_ = value;
}

// int32 moneyPrec = 5;
inline void MarketDto::clear_moneyprec() {
  _impl_.moneyprec_ = 0;
}
inline ::int32_t MarketDto::moneyprec() const {
  // @@protoc_insertion_point(field_get:taocontext.MarketDto.moneyPrec)
  return _internal_moneyprec();
}
inline void MarketDto::set_moneyprec(::int32_t value) {
  _internal_set_moneyprec(value);
  // @@protoc_insertion_point(field_set:taocontext.MarketDto.moneyPrec)
}
inline ::int32_t MarketDto::_internal_moneyprec() const {
  return _impl_.moneyprec_;
}
inline void MarketDto::_internal_set_moneyprec(::int32_t value) {
  ;
  _impl_.moneyprec_ = value;
}

// int32 feePrec = 6;
inline void MarketDto::clear_feeprec() {
  _impl_.feeprec_ = 0;
}
inline ::int32_t MarketDto::feeprec() const {
  // @@protoc_insertion_point(field_get:taocontext.MarketDto.feePrec)
  return _internal_feeprec();
}
inline void MarketDto::set_feeprec(::int32_t value) {
  _internal_set_feeprec(value);
  // @@protoc_insertion_point(field_set:taocontext.MarketDto.feePrec)
}
inline ::int32_t MarketDto::_internal_feeprec() const {
  return _impl_.feeprec_;
}
inline void MarketDto::_internal_set_feeprec(::int32_t value) {
  ;
  _impl_.feeprec_ = value;
}

// int64 minAmount = 7;
inline void MarketDto::clear_minamount() {
  _impl_.minamount_ = ::int64_t{0};
}
inline ::int64_t MarketDto::minamount() const {
  // @@protoc_insertion_point(field_get:taocontext.MarketDto.minAmount)
  return _internal_minamount();
}
inline void MarketDto::set_minamount(::int64_t value) {
  _internal_set_minamount(value);
  // @@protoc_insertion_point(field_set:taocontext.MarketDto.minAmount)
}
inline ::int64_t MarketDto::_internal_minamount() const {
  return _impl_.minamount_;
}
inline void MarketDto::_internal_set_minamount(::int64_t value) {
  ;
  _impl_.minamount_ = value;
}

// int64 minBase = 8;
inline void MarketDto::clear_minbase() {
  _impl_.minbase_ = ::int64_t{0};
}
inline ::int64_t MarketDto::minbase() const {
  // @@protoc_insertion_point(field_get:taocontext.MarketDto.minBase)
  return _internal_minbase();
}
inline void MarketDto::set_minbase(::int64_t value) {
  _internal_set_minbase(value);
  // @@protoc_insertion_point(field_set:taocontext.MarketDto.minBase)
}
inline ::int64_t MarketDto::_internal_minbase() const {
  return _impl_.minbase_;
}
inline void MarketDto::_internal_set_minbase(::int64_t value) {
  ;
  _impl_.minbase_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace taocontext


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::taocontext::OrderType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::taocontext::OrderType>() {
  return ::taocontext::OrderType_descriptor();
}
template <>
struct is_proto_enum<::taocontext::OrderSid> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::taocontext::OrderSid>() {
  return ::taocontext::OrderSid_descriptor();
}
template <>
struct is_proto_enum<::taocontext::OrderCmd> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::taocontext::OrderCmd>() {
  return ::taocontext::OrderCmd_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_taoContext_2eproto_2epb_2eh
